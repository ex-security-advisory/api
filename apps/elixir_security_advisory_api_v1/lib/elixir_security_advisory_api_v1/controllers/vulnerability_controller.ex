defmodule ElixirSecurityAdvisoryApiV1.VulnerabilityController do
  use ElixirSecurityAdvisoryApiV1, :controller

  plug :default_pagination, %{"first" => 10} when action in [:index]

  use Absinthe.Phoenix.Controller, schema: ElixirSecurityAdvisoryApiV1.Schema

  swagger_path :index do
    summary("List vulnerabilities")
    produces("application/json")

    parameter(
      :after,
      :query,
      :string,
      "List entries after cursor"
    )

    parameters do
      affectsVersion(
        :query,
        :string,
        "Only list vulnerabilities that are affecting the given version"
      )

      packageName(:query, :string, "Only list vulnerabilities from given package name")
      first(:query, :integer, "List the first X entries")
      last(:query, :integer, "List the last X entries")
      before(:query, :string, "List entries before cursor")
    end

    response(200, "OK", Schema.ref(:VulnerabilityList))

    response(400, "Bad Request")
  end

  swagger_path :show do
    summary("Show vulnerability")
    produces("application/json")

    parameters do
      id(
        :path,
        :string,
        "The vulnerability id"
      )
    end

    response(200, "OK", Schema.ref(:Vulnerability))

    response(404, "Not Found")
  end

  def swagger_definitions do
    %{
      VulnerabilityList:
        swagger_schema do
          title("Vulnerability List")
          description "List of vulnerabilities"

          properties do
            edges(
              Schema.new do
                type(:array)

                items(
                  Schema.new do
                    properties do
                      node(Schema.ref(:Vulnerability), "Node Object", required: true)
                      cursor(:string, "Cursor", required: true)
                    end
                  end
                )
              end,
              "List of edge nodes"
            )

            pageInfo(Schema.ref(:PageInfo), "Pagination Info", required: true)
          end
        end,
      PageInfo:
        swagger_schema do
          properties do
            endCursor(:string, "List End Cursor", required: true)
            hasNextPag(:boolean, "List has next page", required: true)
            hasPreviousPage(:boolean, "List has previous page", required: true)
            startCursor(:string, "List start Cursor", required: true)
          end

          example(%{
            endCursor: "YXJyYXljb25uZWN0aW9uOjg=",
            hasNextPage: false,
            hasPreviousPage: false,
            startCursor: "YXJyYXljb25uZWN0aW9uOjA="
          })
        end,
      Vulnerability:
        swagger_schema do
          properties do
            id(:string, "Vulnerability ID", required: true)
            cve(:string, "CVE ID", pattern: ~S"^\d{4}-\d{4,}$", required: false)
            description(:string, "Vulnerability description", required: false)
            disclosureDate(:string, "Disclosure Date", format: :date, required: false)
            link(:string, "Disclosure Date", format: :uri, required: false)
            oldestRevisionId(:string, "Revision when Vulnerability was defined", required: true)
            package(Schema.ref(:Package), "Package where vulnerability was found", required: true)

            patchedVersions(
              Schema.new do
                type(:array)

                items(
                  Schema.new do
                    type(:string)
                  end
                )
              end,
              "Patched Package Versions",
              required: false
            )

            title(:string, "Vulnerability title", required: false)

            unaffectedVersions(
              Schema.new do
                type(:array)

                items(
                  Schema.new do
                    type(:string)
                  end
                )
              end,
              "Unaffected Package Versions",
              required: false
            )

            revisions(
              Schema.new do
                type(:array)

                items(Schema.ref(:VulnerabilityRevision))
              end,
              "Unaffected Package Versions",
              required: false
            )
          end

          example(%{
            cve: "2018-20301",
            description:
              "The Coherence library has \"Mass Assignment\"-like vulnerabilities. In particular, \"registration\"\nendpoints (like creating, editing, updating), allow users to update any coherence_fields. This\nmeans that, among other issues, users can automatically confirm their accounts by sending the\nconfirmed_at parameter with their registration request. Further, the library design and\ndocumentation encourages insecure functionality by default.\n\nFor example, the \"store\" demo allows registering users to add themselves as admin:\nhttps://github.com/smpallen99/store/blob/master/web/models/coherence/user.ex",
            disclosureDate: "2017-08-02",
            id: "VnVsbmVyYWJpbGl0eTpwYWNrYWdlcy9jb2hlcmVuY2UvMjAxNy0wOC0wMi55bWw=",
            link: "https://github.com/smpallen99/coherence/issues/270",
            oldestRevisionId: "4a69ca0aa7367ce6265d95c9f72f95039cc5a86e",
            package: %{id: "UGFja2FnZTpjb2hlcmVuY2U=", name: "coherence"},
            patchedVersions: [">= 0.5.2"],
            title: "Permissive parameters and privilege escalation",
            unaffectedVersions: nil,
            revisions: [
              %{
                cve: "2018-20301",
                description:
                  "The Coherence library has \"Mass Assignment\"-like vulnerabilities. In particular, \"registration\"\nendpoints (like creating, editing, updating), allow users to update any coherence_fields. This\nmeans that, among other issues, users can automatically confirm their accounts by sending the\nconfirmed_at parameter with their registration request. Further, the library design and\ndocumentation encourages insecure functionality by default.\n\nFor example, the \"store\" demo allows registering users to add themselves as admin:\nhttps://github.com/smpallen99/store/blob/master/web/models/coherence/user.ex",
                disclosureDate: "2017-08-02",
                link: "https://github.com/smpallen99/coherence/issues/270",
                newestRevisionId: nil,
                oldestRevisionId: "83ea7db3536e7c1cd30ce5f430f41ff38a646103",
                patchedVersions: [">= 0.5.2"],
                revisionMessage:
                  "Merge pull request #11 from maennchen/patch-1\n\nAdd Reserved CVE to Coherence",
                title: "Permissive parameters and privilege escalation",
                unaffectedVersions: nil
              }
            ]
          })
        end,
      VulnerabilityRevision:
        swagger_schema do
          properties do
            cve(:string, "CVE ID", pattern: ~S"^\d{4}-\d{4,}$", required: false)
            description(:string, "Vulnerability description", required: false)
            disclosureDate(:string, "Disclosure Date", format: :date, required: false)
            link(:string, "Disclosure Date", format: :uri, required: false)

            oldestRevisionId(
              :string,
              "Revision when revision was defined",
              required: true
            )

            newestRevisionId(
              :string,
              "Revision when revision was replaced",
              required: false
            )

            revisionMessage(:string, "revision change description", required: true)

            patchedVersions(
              Schema.new do
                type(:array)

                items(
                  Schema.new do
                    type(:string)
                  end
                )
              end,
              "Patched Package Versions",
              required: false
            )

            title(:string, "Vulnerability title", required: false)

            unaffectedVersions(
              Schema.new do
                type(:array)

                items(
                  Schema.new do
                    type(:string)
                  end
                )
              end,
              "Unaffected Package Versions",
              required: false
            )
          end

          example(%{
            cve: "2018-20301",
            description:
              "The Coherence library has \"Mass Assignment\"-like vulnerabilities. In particular, \"registration\"\nendpoints (like creating, editing, updating), allow users to update any coherence_fields. This\nmeans that, among other issues, users can automatically confirm their accounts by sending the\nconfirmed_at parameter with their registration request. Further, the library design and\ndocumentation encourages insecure functionality by default.\n\nFor example, the \"store\" demo allows registering users to add themselves as admin:\nhttps://github.com/smpallen99/store/blob/master/web/models/coherence/user.ex",
            disclosureDate: "2017-08-02",
            link: "https://github.com/smpallen99/coherence/issues/270",
            newestRevisionId: nil,
            oldestRevisionId: "83ea7db3536e7c1cd30ce5f430f41ff38a646103",
            patchedVersions: [">= 0.5.2"],
            revisionMessage:
              "Merge pull request #11 from maennchen/patch-1\n\nAdd Reserved CVE to Coherence",
            title: "Permissive parameters and privilege escalation",
            unaffectedVersions: nil
          })
        end
    }
  end

  @graphql """
    query Vulnerabilities($affectsVersion: Version, $packageName: String, $first: Int, $last: Int, $before: String, $after: String) {
      vulnerabilities(first: $first, last: $last, before: $before, after: $after, affectsVersion: $affectsVersion, packageName: $packageName) {
        pageInfo {
          endCursor
          startCursor
          hasNextPage
          hasPreviousPage
        }
        edges {
          cursor
          node {
            id
            cve
            description
            disclosureDate
            link
            oldestRevisionId
            patchedVersions
            package {
              id
              name
            }
            title
            unaffectedVersions
            revisions {
              cve
              description
              disclosureDate
              link
              oldestRevisionId
              patchedVersions
              title
              unaffectedVersions
              newestRevisionId
              revisionMessage
            }
          }
        }
      }
    }
  """
  def index(conn, %{errors: errors}) do
    conn
    |> put_resp_content_type("application/json")
    |> send_resp(:bad_request, Jason.encode!(errors))
  end

  def index(conn, %{data: %{"vulnerabilities" => vulnerabilities}}) do
    conn
    |> put_resp_content_type("application/json")
    |> send_resp(:ok, Jason.encode!(vulnerabilities))
  end

  @graphql """
    query Vulnerability($id: ID!) {
      node(id: $id) {
        id
        __typename
        ... on Vulnerability {
          cve
          description
          disclosureDate
          link
          oldestRevisionId
          patchedVersions
          package {
            id
            name
          }
          revisions {
            cve
            description
            disclosureDate
            link
            oldestRevisionId
            patchedVersions
            title
            unaffectedVersions
            newestRevisionId
            revisionMessage
          }
          title
          unaffectedVersions
        }
      }
    }
  """
  def show(conn, %{errors: errors}) do
    conn
    |> put_resp_content_type("application/json")
    |> send_resp(:bad_request, Jason.encode!(errors))
  end

  def show(conn, %{data: %{"node" => %{"__typename" => type}}}) when type != "Vulnerability" do
    conn
    |> put_status(:not_found)
    |> put_view(ElixirSecurityAdvisoryApi.ErrorView)
    |> render("404.json")
  end

  def show(conn, %{data: %{"node" => nil}}) do
    conn
    |> put_status(:not_found)
    |> put_view(ElixirSecurityAdvisoryApi.ErrorView)
    |> render("404.json")
  end

  def show(conn, %{data: %{"node" => node}}) do
    conn
    |> put_resp_content_type("application/json")
    |> send_resp(:ok, Jason.encode!(node))
  end
end
