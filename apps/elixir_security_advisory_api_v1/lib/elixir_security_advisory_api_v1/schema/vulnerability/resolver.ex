defmodule ElixirSecurityAdvisoryApiV1.Schema.Vulnerability.Resolver do
  @moduledoc false

  @vulnerabilities Application.fetch_env!(:elixir_security_advisory, ElixirSecurityAdvisory)

  use Amnesia

  alias Absinthe.Relay.Connection

  def vulnerabilities(_parent, %{package_name: package} = args, _resolution) do
    Amnesia.transaction do
      list =
        package
        |> @vulnerabilities.get_package_by_name()
        |> case do
          nil -> []
          %{} = package -> @vulnerabilities.list_vulnerabilities_by_package(package)
        end
        |> filter_affected_by(args[:affects_version])

      Connection.from_list(list, Map.take(args, [:before, :after, :first, :last]))
    end
  end

  def vulnerabilities(_parent, %{affects_version: %Version{}}, _resolution) do
    {:error, :only_use_affected_version_with_specific_package}
  end

  def vulnerabilities(_parent, args, _resolution) do
    Amnesia.transaction do
      @vulnerabilities.list_vulnerabilities()
      |> Enum.to_list()
      |> Connection.from_list(args)
    end
  end

  def package(vulnerability, _args, _resolution) do
    Amnesia.transaction do
      {:ok, @vulnerabilities.get_package_by_vulnerability(vulnerability)}
    end
  end

  def revision_field(field) do
    fn %{revisions: [%{^field => value} | _]}, _args, _resolution ->
      {:ok, value}
    end
  end

  def oldest_revision_id(%{revisions: revisions}, _args, _resolution) do
    Map.fetch(List.last(revisions), :oldest_revision_id)
  end

  defp filter_affected_by([], _version), do: []
  defp filter_affected_by(vulnerabilities, nil), do: vulnerabilities

  defp filter_affected_by(vulnerabilities, version) do
    Enum.filter(vulnerabilities, &ElixirSecurityAdvisory.affected_by(&1, version))
  end
end
